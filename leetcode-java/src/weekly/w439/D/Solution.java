package weekly.w439.D;

/**
 * 3474. Lexicographically Smallest Generated String
 *
 * https://leetcode.cn/contest/weekly-contest-439/problems/lexicographically-smallest-generated-string/
 *
 * You are given two strings, str1 and str2, of lengths n and m, respectively.
 *
 * A string word of length n + m - 1 is defined to be generated by str1 and str2
 * if it satisfies the following conditions for each index 0 <= i <= n - 1:
 *
 * If str1[i] == 'T', the substring of word with size m starting
 * at index i is equal to str2, i.e., word[i..(i + m - 1)] == str2.
 *
 * If str1[i] == 'F', the substring of word with size m starting
 * at index i is not equal to str2, i.e., word[i..(i + m - 1)] != str2.
 *
 * Return the lexicographically smallest possible string that can be generated by str1 and str2.
 * If no string can be generated, return an empty string "".
 */

public class Solution {

    public String generateString(String str1, String str2) {
        int n = str1.length(), m = str2.length();
        char[] target = str2.toCharArray();

        char[] pattern = new char[n + m - 1];
        // 先填充所有需要相同的的位置
        for (int i = 0; i < n; i++) {
            if (str1.charAt(i) == 'T') {
                // 从 i 开始填充 pattern, 内容为 str2
                for (int j = 0; j < m; j++) {
                    if (pattern[i + j] == 0) pattern[i + j] = target[j];
                    // 如果已经填充过的位置且内容不相同, 则返回错误
                    if (pattern[i + j] != target[j]) return "";
                }
            }
        }

        char[] ans = new char[pattern.length];
        System.arraycopy(pattern, 0, ans, 0, pattern.length);
        // 我们先把所有的空位都填上 a, 之后遇到不匹配的再填上 b
        for (int i = 0; i < ans.length; i++) if (ans[i] == 0) ans[i] = 'a';

        // 再逐个填充所有需要不同的位置, 为了使字典序最小需要优先填 a
        for (int i = 0; i < n; i++) {
            if (str1.charAt(i) == 'T') continue;
            if (!equals(ans, i, target)) continue;

            // 此时意味着从位置 i 开始的子字符串等于 target 了
            // 我们需要找到最后一个位置并将其修改为 b
            boolean ok = false;
            for (int j = i + m - 1; j >= i; j--) {
                if (pattern[j] == 0) { ans[j] = 'b'; ok = true; break; }
            }
            if (!ok) return "";
        }

        return new String(ans);
    }

    private boolean equals(char[] ans, int i, char[] target) {
        for (int j = 0; j < target.length; j++) {
            if (ans[i + j] != target[j]) return false;
        }
        return true;
    }

    public static void main(String[] args) {
        assert new Solution().generateString("FFTFFF", "a").equals("bbabbb");
        assert new Solution().generateString("TFFFTFFF", "bab").equals("babbbabaaa");
        assert new Solution().generateString("FT", "wvxyy").equals("awvxyy");

        assert new Solution().generateString("TFTF", "ab").equals("ababa");
        assert new Solution().generateString("TFTF", "abc").equals("");
        assert new Solution().generateString("F", "d").equals("a");
        assert new Solution().generateString("F", "da").equals("aa");
    }

}
