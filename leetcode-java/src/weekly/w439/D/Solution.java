package weekly.w439.D;

/**
 * 3474. Lexicographically Smallest Generated String
 *
 * https://leetcode.cn/contest/weekly-contest-439/problems/lexicographically-smallest-generated-string/
 *
 * You are given two strings, str1 and str2, of lengths n and m, respectively.
 *
 * A string word of length n + m - 1 is defined to be generated by str1 and str2
 * if it satisfies the following conditions for each index 0 <= i <= n - 1:
 *
 * If str1[i] == 'T', the substring of word with size m starting
 * at index i is equal to str2, i.e., word[i..(i + m - 1)] == str2.
 *
 * If str1[i] == 'F', the substring of word with size m starting
 * at index i is not equal to str2, i.e., word[i..(i + m - 1)] != str2.
 *
 * Return the lexicographically smallest possible string that can be generated by str1 and str2.
 * If no string can be generated, return an empty string "".
 */

public class Solution {

    public String generateString(String str1, String str2) {
        int n = str1.length(), m = str2.length();
        char[] chars2 = str2.toCharArray();

        char[] ans = new char[n + m - 1];
        for (int i = 0; i < n; i++) {
            if (str1.charAt(i) == 'T') {
                // 从 i 开始填充 ans, 内容为 str2
                for (int j = 0; j < m; j++) {
                    if (ans[i + j] != 0 && ans[i + j] != chars2[j]) return "";
                    ans[i + j] = chars2[j];
                }
            }
        }

        for (int i = 0; i < n; i++) {
            if (str1.charAt(i) == 'F') {
                // 检查空白位置可以填入什么, 如果在 m 长度内已经有一个字符不一样了
                boolean unmatched = false, useA = false; int last = -1;
                for (int j = 0; j < m; j++) {
                    unmatched = unmatched || ans[i + j] != 0 && ans[i + j] != chars2[j];
                    useA = useA || ans[i + j] == 0 && chars2[j] != 'a';
                    if (ans[i + j] == 0) last = j;
                }
                if (!unmatched && last == -1) return "";

                // 如果已经有不一样的字符了, 那么剩下的都可以填 a
                // 否则我们将这个范围内的空格的最后一个空位填成不等于 chars[j] 的字母, 其他填a
                if (!unmatched && !useA) ans[i + last] = chars2[last] == 'a' ? 'b' : 'a';
                for (int j = 0; j < m; j++) if (ans[i + j] == 0) ans[i + j] = 'a';
            }
        }

        return new String(ans);
    }

    public static void main(String[] args) {
        // b a b _ b a b _ _ _
        //   b a ^ 这里不能为 a 因为 i = 2 时要求
        assert new Solution().generateString("TFFFTFFF", "bab").equals("babbbabaaa");
        assert new Solution().generateString("FT", "wvxyy").equals("awvxyy");

        assert new Solution().generateString("TFTF", "ab").equals("ababa");
        assert new Solution().generateString("TFTF", "abc").equals("");
        assert new Solution().generateString("F", "d").equals("a");
        assert new Solution().generateString("F", "da").equals("aa");
    }

}
